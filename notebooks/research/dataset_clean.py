# -*- coding: utf-8 -*-
"""dataset_clean.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1GzXOmXprQYE9TrkSP-weDtb-Q4KvTFkG

разбор датасета на ру и енг

## Анализ музыкального датасета Spotify

Перед извлечением пользовательских предпочтений проводится анализ музыкального
датасета Spotify (1921–2020) с целью определения допустимых языков треков и
жанров, представленных в данных.
"""

!mkdir -p ~/.kaggle
!cp kaggle.json ~/.kaggle/
!chmod 600 ~/.kaggle/kaggle.json

!kaggle datasets download -d maharshipandya/-spotify-tracks-dataset

!unzip spotify-dataset-1921-2020-160k-tracks.zip -d dataset_a
!unzip spotify-tracks-dataset.zip -d dataset_b

!ls dataset_a
!ls dataset_b

df_tracks = pd.read_csv("dataset_a/data.csv")
df_tracks.columns

import pandas as pd

df_tracks = pd.read_csv("tracks.csv")
df_artists = pd.read_csv("artists.csv")

df_tracks.columns

df_artists.columns

def norm(s):
    return str(s).lower().strip()

df_tracks["artist_norm"] = df_tracks["artist"].apply(norm)
df_artists["artist_norm"] = df_artists["artist"].apply(norm)

df_artists_genres = df_artists[["artist_norm", "genres"]].copy()

df_merged = pd.merge(
    df_tracks,
    df_artists_genres,
    on="artist_norm",
    how="left"
)

df_merged = df_merged.drop(columns=["artist_norm"])

df_merged["spotify_id"].isna().mean()

df_merged["genres"].notna().mean()

df_merged[["spotify_id", "artist", "name", "genres"]].head(10)

df_merged.to_csv("tracks_with_genres.csv", index=False)

df_merged.columns

df_dataset.columns

df_dataset = pd.read_csv("dataset_b/dataset.csv")

df_dataset = df_dataset.drop(columns=["Unnamed: 0"], errors="ignore")

df_dataset = df_dataset.rename(columns={
    "artists": "artist",
    "track_name": "name",
    "track_genre": "genres"
})

df_dataset.columns

for col in df_merged.columns:
    if col not in df_dataset.columns:
        df_dataset[col] = pd.NA

df_dataset_aligned = df_dataset[df_merged.columns].copy()

existing_ids = set(df_merged["spotify_id"].dropna())

df_dataset_new = df_dataset_aligned[
    ~df_dataset_aligned["spotify_id"].isin(existing_ids)
].copy()

df_full = pd.concat(
    [df_merged, df_dataset_new],
    ignore_index=True
)

df_full["spotify_id"].duplicated().sum()

df_merged.shape, df_dataset_new.shape, df_full.shape

df_full.to_csv("tracks_full_unified.csv", index=False)

df_tracks = pd.read_csv("dataset_a/data.csv")

df_genres = pd.read_csv("dataset_a/data_by_genres.csv")

df_tracks.columns

df_genres.columns

FEATURES = [
    "energy",
    "loudness",
    "danceability",
    "valence",
    "tempo",
    "acousticness",
    "instrumentalness",
    "liveness",
    "speechiness"
]

df_tracks_feat = df_tracks.dropna(subset=FEATURES).copy()
df_genres_feat = df_genres.dropna(subset=FEATURES).copy()

from sklearn.preprocessing import StandardScaler

scaler = StandardScaler()

df_tracks_feat[FEATURES] = scaler.fit_transform(df_tracks_feat[FEATURES])
df_genres_feat[FEATURES] = scaler.transform(df_genres_feat[FEATURES])

from sklearn.metrics.pairwise import cosine_distances
import numpy as np

genre_vectors = df_genres_feat[FEATURES].values
track_vectors = df_tracks_feat[FEATURES].values

distances = cosine_distances(track_vectors, genre_vectors)

nearest_genre_idx = np.argmin(distances, axis=1)

df_tracks_feat["genres"] = df_genres_feat.iloc[nearest_genre_idx]["genres"].values

df_tracks = df_tracks.merge(
    df_tracks_feat[["id", "genres"]],
    on="id",
    how="left"
)

df_tracks["genres"].notna().mean()

df_tracks[["artists", "name", "genres"]].head(20)

df_tracks

df_tracks.to_csv("tracks_with_genres_filled.csv", index=False)

df_full = pd.read_csv(
    "tracks_full_unified.csv",
    low_memory=False
)

df_full.columns

df_filled = pd.read_csv(
    "tracks_with_genres_filled.csv",
    low_memory=False
)

df_filled.columns

set(df_full.columns) - set(df_filled.columns)

set(df_filled.columns) - set(df_full.columns)

df_filled = df_filled.rename(columns={
    "id": "spotify_id",
    "artists": "artist"
})

df_filled = df_filled.drop(columns=["year"], errors="ignore")

for col in df_full.columns:
    if col not in df_filled.columns:
        df_filled[col] = pd.NA

df_filled = df_filled[df_full.columns]

existing_ids = set(df_full["spotify_id"].dropna())

df_filled_new = df_filled[
    ~df_filled["spotify_id"].isin(existing_ids)
].copy()

df_final = pd.concat(
    [df_full, df_filled_new],
    ignore_index=True
)

df_final["spotify_id"].duplicated().sum()

df_full.shape, df_filled_new.shape, df_final.shape

df_final.to_csv("tracks_final_ready.csv", index=False)

import re

def parse_artists(raw):
    if not isinstance(raw, str):
        return []

    s = raw.lower()

    s = re.sub(r"\([^)]*\)", "", s)
    s = re.sub(r"\[[^\]]*\]", "", s)
    s = re.sub(r"\{[^}]*\}", "", s)

    separators = [
        r"\s+feat\.?\s+",
        r"\s+ft\.?\s+",
        r"\s+featuring\s+",
        r"\s*&\s*",
        r"\s*,\s*",
        r"\s*/\s*",
        r"\s+x\s+",
    ]

    for sep in separators:
        s = re.sub(sep, ";", s)

    artists = [a.strip() for a in s.split(";") if a.strip()]
    return artists

import pandas as pd
import ast

df = pd.read_csv("tracks_final_ready.csv")

def parse_genres(x):
    try:
        return ast.literal_eval(x)
    except:
        return []

df["genres_parsed"] = df["genres"].apply(parse_genres)

df["artist_list"] = df["artist"].apply(parse_artists)

df_exploded = df.explode("artist_list").rename(
    columns={"artist_list": "artist_clean"}
)

df_exploded = df_exploded.dropna(subset=["artist_clean"])

artists_unique = (
    df_exploded
    .groupby("artist_clean")
    .agg(
        genres=("genres_parsed", lambda x: sorted(set(g for sub in x for g in sub))),
        avg_instrumentalness=("instrumentalness", "mean"),
        max_instrumentalness=("instrumentalness", "max"),
        tracks_count=("spotify_id", "count"),
    )
    .reset_index()
)

artists_unique["language"] = None
artists_unique["instrumental"] = None
artists_unique["notes"] = None

artists_unique.to_csv(
    "artists_unique_normalized.csv",
    index=False
)

artists = pd.read_csv("artists_unique_normalized.csv")

def has_cyrillic(text):
    if not isinstance(text, str):
        return False
    return bool(re.search(r"[А-Яа-яЁё]", text))

def has_chinese(text):
    if not isinstance(text, str):
        return False
    return bool(re.search(r"[\u4e00-\u9fff]", text))

def detect_language_simple(name):
    if has_cyrillic(name):
        return "ru"
    if has_chinese(name):
        return "china"
    return "other"

artists["language_auto"] = artists["artist_clean"].apply(detect_language_simple)

artists["language_auto"].value_counts()

artists[artists["language_auto"] == "ru"].sample(20)

artists[artists["language_auto"] == "china"].sample(20)

import os
[f for f in os.listdir(".") if f.endswith(".csv")]

artists.to_csv(
    "artists_unique_normalized_with_language.csv",
    index=False
)

import pandas as pd
import ast

artists = pd.read_csv("artists_unique_normalized_with_language.csv")

def parse_genres_safe(x):
    if isinstance(x, list):
        return x
    try:
        return ast.literal_eval(x)
    except:
        return []

artists["genres_parsed"] = artists["genres"].apply(parse_genres_safe)

type(artists.loc[0, "genres_parsed"])

INSTRUMENTAL_GENRE_KEYWORDS = [
    "instrumental",
    "classical",
    "piano",
    "orchestra",
    "orchestral",
    "symphony",
    "soundtrack",
    "score",
    "neoclassical",
    "ambient",
]

RUSSIAN_GENRE_KEYWORDS = [
    "russian",
    "rus",
]

def update_language_by_genres(row):
    genres = row["genres_parsed"]

    for g in genres:
        gl = g.lower()
        if any(k in gl for k in INSTRUMENTAL_GENRE_KEYWORDS):
            return "instrumental"

    for g in genres:
        gl = g.lower()
        if any(k in gl for k in RUSSIAN_GENRE_KEYWORDS):
            return "ru"

    return row["language_auto"]

artists["language_auto"] = artists.apply(
    update_language_by_genres,
    axis=1
)

artists["language_auto"].value_counts()

def update_language_with_audio(row):
    if row["language_auto"] == "instrumental":
        return "instrumental"

    if (
        row["avg_instrumentalness"] >= 0.6
        or row["max_instrumentalness"] >= 0.8
    ):
        return "instrumental"

    return row["language_auto"]

artists["language_auto"] = artists.apply(
    update_language_with_audio,
    axis=1
)

artists["language_auto"].value_counts()

SEED_RU_LATIN = {
    "morgenstern",
    "face",
    "boulevard depo",
    "kizaru",
    "og buda",
    "scally milano",
    "mayot",
    "seemee",
    "soda luv",
    "markul",
    "big baby tape",
    "lovv66",
    "t-fest",
    "miyagi",
    "yanix",
    "jony",
    "mot",
    "zivert",
    "klava koka",
    "mary gu",
    "demmi",
    "niletto",
    "rasa",
    "katerina",
    "хлеб",
    "ic3peak",
    "pornofilms",
    "louna",
    "slot",
    "bi-2",
    "xena",
    "lizer",
    "mirele",
    "sssshhiiittt!",
    "t.a.t.u.",
    "gone.fludd",
    "ten walls",
    "lil morty",
    "feduk",
    "m'dee",
    "kai angel",
    "trill d",
    "jeembo",
    "bushido zho",
    "alblak 52",
    "maybe baby",
    "saluki",
    "berry",
    "loqeranjean",
    "anikv",
    "tveth",
    "mona",
    "gidra",
    "zoloto",
    "marcel",
    "lostage",
    "smilelikeme",
    "deep-ex-sense",
    "breezzy",
    "whatever",
    "noize mc",
    "anacondaz",
    "the hatters",
    "2rbina 2rista",
    "otyken",
    "savage",
    "kalvados",
    "glebasta spal",
    "pharaoh",
    "pyrokinesis",
    "sqwoz bab",
    "muto",
    "moneyken",
    "termitegod",
    "lemmon juice",
    "swanky tunes",
    "dj smash",
    "swany",
    "kurt92",
    "sted.d",
    "pussykiller",
    "atl",
    "malbec",
    "cakeboy",
    "v $ x v prince",
    "from russia with brat",
    "krestall / courier",
    "dvrklxght",
    "openspace",
    "lil krystalll",
    "goatmilky",
    "lil kavkaz",
    "aigel",
    "netslow",
    "gayazov$ brother$",
    "katya gelmet",
    "janaga",
    "roxette rus",
    "tenderlybane",
    "ivan dorn",
    "jah khalib",
    "elman",
    "slava marlow",
    "zapomni",
    "doni",
    "mufassa",
    "sandr",
    "culture of kefir",
    "roman kazanov",
    "dark side of suburbia",
    "baby melon",
    "sadonray",
    "smarty",
    "cheev",
    "nazima",
    "arut",
    "wensdei",
    "ollane",
    "amri",
    "danchik rezni4eckiy",
    "mister bin",
    "shnyrov",
}

artists.to_csv(
    "artists_unique_normalized_with_language_genres.csv",
    index=False
)

import pandas as pd

artists = pd.read_csv("artists_unique_normalized_with_language_genres.csv")

artists["artist_clean"] = artists["artist_clean"].astype(str).str.lower()

before = artists["language_auto"].value_counts()

artists.loc[
    artists["artist_clean"].isin(SEED_RU_LATIN),
    "language_auto"
] = "ru"

after = artists["language_auto"].value_counts()

before

artists.to_csv(
    "artists_unique_final_with_language_auto_1_3.csv",
    index=False
)

import pandas as pd

df = pd.read_excel("result.xlsx")

mask_empty = df["language"].isna() | (df["language"].astype(str).str.strip() == "")

df.loc[mask_empty, "language"] = df.loc[mask_empty, "language_auto"]

df["language"].value_counts()

df["language"] = df["language"].replace("china", "other")

df["language"] = df["language"].replace("instrumenal", "instrumental")

df["language"].value_counts()

df.to_excel(
    "artists_unique_FINAL.xlsx",
    index=False
)

artists = pd.read_excel("artists_unique_FINAL.xlsx")
tracks = pd.read_csv("tracks_final_ready_normalized_artists.csv")

artists.columns

tracks.columns

tracks = tracks.rename(columns={"artist": "artist_clean"})

tracks["artist_clean"] = tracks["artist_clean"].astype(str).str.lower().str.strip()
artists["artist_clean"] = artists["artist_clean"].astype(str).str.lower().str.strip()

tracks["artist_clean"].head()

artists["artist_clean"].head()

import ast

def parse_artist_list(x):
    if isinstance(x, list):
        return x
    try:
        return ast.literal_eval(x)
    except:
        return []

tracks["artist_list"] = tracks["artist_clean"].apply(parse_artist_list)

tracks["artist_list"].head()

tracks_exploded = tracks.explode("artist_list").reset_index(drop=True)

tracks_exploded["artist_list"].head()

tracks_exploded["artist_clean_norm"] = (
    tracks_exploded["artist_list"]
    .astype(str)
    .str.lower()
    .str.strip()
)

artists["artist_clean_norm"] = (
    artists["artist_clean"]
    .astype(str)
    .str.lower()
    .str.strip()
)

tracks_exploded = tracks_exploded.merge(
    artists[["artist_clean_norm", "language"]],
    on="artist_clean_norm",
    how="left"
)

tracks_exploded["language"] = tracks_exploded["language"].fillna("other")

tracks_final = (
    tracks_exploded
    .groupby(tracks_exploded.index)
    .first()
    .reset_index(drop=True)
)

tracks_final["language"].value_counts()

tracks_final.sample(20)[["artist_list", "language"]]

tracks_final.to_csv(
    "tracks_with_language_FINAL.csv",
    index=False,
    encoding="utf-8-sig"
)